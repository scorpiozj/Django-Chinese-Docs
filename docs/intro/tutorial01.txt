=====================================
编写你的第一个 Django 程序 第1部分
=====================================

让我们通过例子来学习。

在本教程中，我们将引导您创建一个基本的投票应用。

它将包含两部分：

* 一个公共网站，可让人们查看投票的结果和让他们进行投票。
* 一个管理网站，可让你添加、修改和删除投票项目。

我们假设你已经 :doc:`安装了 Django </intro/install>` 。你可以运行以下命令来验证是否已经安装了 Django 和运行着的版本号：

.. code-block:: bash

    python -c "import django; print(django.get_version())"

你应该看到你安装的 Django 版本或一个提示你 "No module named django" 的错误。此外，还应该检查下你的版本与本教程的版本是否一致。
若不一致，你可以参考 Django 版本对应的教程或者更新 Django 到最新版本。

请参考 :doc:`如何安装 Django </topics/install>` 中的意见先删除旧版本的 Django 再安装一个新的。

.. admonition:: 在哪里可以获得帮助：

    如果您在学习本教程中遇到问题，请在 `django-users`__  上发贴或者在 `#django on irc.freenode.net`__ 上与其他可能会帮助您的 Django 用户交流。

__ http://groups.google.com/group/django-users
__ irc://irc.freenode.net/django

创建一个项目
==================

如果这是你第一次使用 Django
，那么你必须进行一些初始设置。也就是通过自动生成代码来建立一个 Django 项目
:term:`project` -- 一个 Django 项目的设置集，包含了数据库配置、 Django 详细选项设置和应用特性配置。

在命令行中，使用 ``cd`` 命令进入你想存储代码所在的目录，然后运行以下命令：

.. code-block:: bash

   django-admin.py startproject mysite

这将在当前目录创建一个 ``mysite`` 目录。如果失败了，请查看 :ref:`troubleshooting-django-admin-py`.

.. note::

    你需要避免使用 python 保留字或 Django 组件名作为项目的名称。尤其是你应该避免使用的命名如： ``django`` (与 Django 本身会冲突) 或者 ``test`` (与 Python 内置的包名会冲突).

.. admonition:: 这段代码应该放在哪里？

    如果你有一般 PHP 的编程背景（未使用流行的框架），可能会将你的代码放在 Web 服务器的文档根目录下（例如：``/var/www``）。而在 Django 中，你不必这么做。将任何 Python 代码放在你的 Web 服务器文档根目录不会是一个好主意，因为这可能会增加人们通过 Web 方式查看到你的代码的风险。这不利于安全。

    将你的代码放在你的文档根目录 **以外** 的某些目录, 例如 :file:`/home/mycode` 。

让我们来看看 :djadmin:`startproject` 都创建了些什么::

    mysite/
        manage.py
        mysite/
            __init__.py
            settings.py
            urls.py
            wsgi.py

.. admonition:: 和你看到的不一样？

    默认的项目布局最近刚刚改变过。如果你看到的是一个“扁平”结构的目录布局（没有内层 :file:`mysite/` 目录），你很可能正在使用一个和本教程版本不一致的 Django 版本。你需要切换到对应的旧版教程或者使用较新的 Django 版本。

这些文件是：

* 外层 :file:`mysite/` 目录只是你项目的一个容器。对于 Django 来说该目录名并不重要; 你可以重命名为你喜欢的。

* :file:`manage.py`: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。 你可以在 :doc:`/ref/django-admin` 中查看关于 :file:`manage.py` 所有的细节。

* 内层 :file:`mysite/` 目录是你项目中的实际 Python 包。该目录名就是 Python 包名，通过它你可以导入它里面的任何东西。 (e.g. ``import mysite.settings``).

* :file:`mysite/__init__.py`: 一个空文件，告诉 Python 该目录是一个 Python 包。(如果你是 Python 新手，请查看官方文档了解 `关于包的更多内容`_ 。)

* :file:`mysite/settings.py`: 该 Django 项目的设置/配置。请查看 :doc:`/topics/settings` 将会告诉你如何设置。

* :file:`mysite/urls.py`: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站“目录”。请查看 :doc:`/topics/http/urls` 可以获取更多有关 URL 的信息。

* :file:`mysite/wsgi.py`: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。请查看 :doc:`/howto/deployment/wsgi/index` 获取更多细节。

.. _关于包的更多内容: http://docs.python.org/tutorial/modules.html#packages

开发用服务器
----------------------

让我们来验证是否工作。从外层 :file:`mysite` 目录切换进去，若准备好了就运行命令 ``python manage.py runserver``。你将会看到命令行输出如下内容：

.. parsed-literal::

    Validating models...

    0 errors found
    |today| - 15:50:53
    Django version |version|, using settings 'mysite.settings'
    Development server is running at http://127.0.0.1:8000/
    Quit the server with CONTROL-C.

你已经启动了 Django 开发服务器，一个纯粹的由 Python 编写的轻量级 Web 服务器。我们在 Django 内包含了这个服务器，这样你就可以迅速开发了，在产品投入使用之前不必去配置一台生产环境下的服务器 -- 例如 Apache 。

现在是一个很好的提示时机：**不要** 在任何类似生产环境中使用此服务器。它仅适用于开发环境。(我们提供的是 Web 框架的业务，而不是 Web 服务器。)

现在服务器正在运行中，请在你的 Web 浏览器中访问 http://127.0.0.1:8000/ 。
你会看到一个令人愉悦的，柔和的淡蓝色 "Welcome to Django" 页面。它工作正常！

.. admonition:: 更改端口号

    默认情况下，:djadmin:`runserver` 命令启动的开发服务器只监听本地 IP 的 8000 端口。

    如果你想改变服务器的端口，把它作为一个命令行参数传递即可。例如以下命令启动的服务器将监听 8080 端口：

    .. code-block:: bash

        python manage.py runserver 8080

    如果你想改变服务器 IP ，把它和端口号一起传递即可。因此，要监听所有公共 IP 地址（如果你想在其他电脑上炫耀你的工作），请使用：

    .. code-block:: bash

        python manage.py runserver 0.0.0.0:8000

    有关开发服务器的完整文档可以在 :djadmin:`runserver` 内参考。

数据库设置
--------------

现在，编辑 :file:`mysite/settings.py` 。 这是一个普通的 Python 模块，包含了代表 Django 设置的模块级变量。
更改 :setting:`DATABASES` 中  ``'default'`` 下的以下键的值，以匹配您的数据库连接设置。

* :setting:`ENGINE <DATABASE-ENGINE>` -- 从
  ``'django.db.backends.postgresql_psycopg2'``,
  ``'django.db.backends.mysql'``, ``'django.db.backends.sqlite3'``,
  ``'django.db.backends.oracle'`` 中选一个， 至于其他请查看 :setting:`also available
  <DATABASE-ENGINE>`.

* :setting:`NAME` -- 你的数据库名。如果你使用 SQLite，该数据库将是你计算机上的一个文件；在这种情况下，:setting:`NAME` 将是一个完整的绝对路径，而且还包含该文件的名称。如果该文件不存在，它会在第一次同步数据库时自动创建（见下文）。

  当指定路径时，总是使用正斜杠，即使是在 Windows 下(例如：``C:/homes/user/mysite/sqlite3.db``) 。

* :setting:`USER` -- 你的数据库用户名 ( SQLite 下不需要) 。

* :setting:`PASSWORD` -- 你的数据库密码 ( SQLite 下不需要) 。

* :setting:`HOST` -- 你的数据库主机地址。如果和你的数据库服务器是同一台物理机器，请将此处保留为空 (或者设置为 ``127.0.0.1``) ( SQLite 下不需要) 。查看 :setting:`HOST` 了解详细信息。

如果你是新建数据库，我们建议只使用 SQLite ，将 :setting:`ENGINE <DATABASE-ENGINE>` 改为 ``'django.db.backends.sqlite3'`` 并且将 :setting:`NAME` 设置为你想存放数据库的地方。 SQLite 是内置在 Python 中的，因此你不需要安装任何东西来支持你的数据库。

.. note::

    如果你使用 PostgreSQL 或者 MySQL，确保你已经创建了一个数据库。还是通过你的数据库交互接口中的 "``CREATE DATABASE database_name;``" 命令做到这一点的。

    如果你使用 SQLite ，你不需要事先创建任何东西 - 在需要的时候，将会自动创建数据库文件。

当你编辑 :file:`settings.py` 时，将 :setting:`TIME_ZONE` 修改为你所在的时区。默认值是美国中央时区（芝加哥）。

同时，注意文件底部的 :setting:`INSTALLED_APPS` 设置。它保存了当前 Django 实例已激活的所有 Django 应用。每个应用可以被多个项目使用，而且你可以打包和分发给其他人在他们的项目中使用。

默认情况下，:setting:`INSTALLED_APPS` 包含以下应用，这些都是由 Django 提供的：

* :mod:`django.contrib.auth` -- 身份验证系统。

* :mod:`django.contrib.contenttypes` -- 内容类型框架。

* :mod:`django.contrib.sessions` --  session 框架。

* :mod:`django.contrib.sites` -- 网站管理框架。

* :mod:`django.contrib.messages` -- 消息框架。

* :mod:`django.contrib.staticfiles` -- 静态文件管理框架。

这些应用在一般情况下是默认包含的。

所有这些应用中每个应用至少使用一个数据库表，所以在使用它们之前我们需要创建数据库中的表。要做到这一点，请运行以下命令：

.. code-block:: bash

    python manage.py syncdb

:djadmin:`syncdb` 命令参照 :setting:`INSTALLED_APPS` 设置，并在你的 :file:`settings.py` 文件所配置的数据库中创建必要的数据库表。每创建一个数据库表你都会看到一条消息，接着你会看到一个提示询问你是否想要在身份验证系统内创建个超级用户。按提示输入后结束。

如果你感兴趣，可以在你的数据库命令行下输入：``\dt`` (PostgreSQL), ``SHOW TABLES;`` (MySQL), 或 ``.schema`` (SQLite) 来列出 Django 所创建的表。

.. admonition:: 对于极简主义者

    就像我们上面所说的，一般情况下以上应用都默认包含在内，但不是每个人都需要它们。如果不需要某些或全部应用，在运行 :djadmin:`syncdb` 命令前可从 :setting:`INSTALLED_APPS` 内随意注释或删除相应的行。:djadmin:`syncdb` 命令只会为 :setting:`INSTALLED_APPS` 内的应用创建表。

.. _creating-models:

Creating models
===============

Now that your environment -- a "project" -- is set up, you're set to start
doing work.

Each application you write in Django consists of a Python package, somewhere
on your `Python path`_, that follows a certain convention. Django comes with a
utility that automatically generates the basic directory structure of an app,
so you can focus on writing code rather than creating directories.

.. admonition:: Projects vs. apps

    What's the difference between a project and an app? An app is a Web
    application that does something -- e.g., a Weblog system, a database of
    public records or a simple poll app. A project is a collection of
    configuration and apps for a particular Web site. A project can contain
    multiple apps. An app can be in multiple projects.

Your apps can live anywhere on your `Python path`_. In this tutorial, we'll
create our poll app right next to your :file:`manage.py` file so that it can be
imported as its own top-level module, rather than a submodule of ``mysite``.

To create your app, make sure you're in the same directory as :file:`manage.py`
and type this command:

.. code-block:: bash

    python manage.py startapp polls

That'll create a directory :file:`polls`, which is laid out like this::

    polls/
        __init__.py
        models.py
        tests.py
        views.py

This directory structure will house the poll application.

The first step in writing a database Web app in Django is to define your models
-- essentially, your database layout, with additional metadata.

.. admonition:: Philosophy

   A model is the single, definitive source of data about your data. It contains
   the essential fields and behaviors of the data you're storing. Django follows
   the :ref:`DRY Principle <dry>`. The goal is to define your data model in one
   place and automatically derive things from it.

In our simple poll app, we'll create two models: ``Poll`` and ``Choice``.
A ``Poll`` has a question and a publication date. A ``Choice`` has two fields:
the text of the choice and a vote tally. Each ``Choice`` is associated with a
``Poll``.

These concepts are represented by simple Python classes. Edit the
:file:`polls/models.py` file so it looks like this::

    from django.db import models

    class Poll(models.Model):
        question = models.CharField(max_length=200)
        pub_date = models.DateTimeField('date published')

    class Choice(models.Model):
        poll = models.ForeignKey(Poll)
        choice_text = models.CharField(max_length=200)
        votes = models.IntegerField(default=0)

The code is straightforward. Each model is represented by a class that
subclasses :class:`django.db.models.Model`. Each model has a number of class
variables, each of which represents a database field in the model.

Each field is represented by an instance of a :class:`~django.db.models.Field`
class -- e.g., :class:`~django.db.models.CharField` for character fields and
:class:`~django.db.models.DateTimeField` for datetimes. This tells Django what
type of data each field holds.

The name of each :class:`~django.db.models.Field` instance (e.g. ``question`` or
``pub_date`` ) is the field's name, in machine-friendly format. You'll use this
value in your Python code, and your database will use it as the column name.

You can use an optional first positional argument to a
:class:`~django.db.models.Field` to designate a human-readable name. That's used
in a couple of introspective parts of Django, and it doubles as documentation.
If this field isn't provided, Django will use the machine-readable name. In this
example, we've only defined a human-readable name for ``Poll.pub_date``. For all
other fields in this model, the field's machine-readable name will suffice as
its human-readable name.

Some :class:`~django.db.models.Field` classes have required arguments.
:class:`~django.db.models.CharField`, for example, requires that you give it a
:attr:`~django.db.models.CharField.max_length`. That's used not only in the
database schema, but in validation, as we'll soon see.

A :class:`~django.db.models.Field` can also have various optional arguments; in
this case, we've set the :attr:`~django.db.models.Field.default` value of
``votes`` to 0.

Finally, note a relationship is defined, using
:class:`~django.db.models.ForeignKey`. That tells Django each ``Choice`` is related
to a single ``Poll``. Django supports all the common database relationships:
many-to-ones, many-to-manys and one-to-ones.

.. _`Python path`: http://docs.python.org/tutorial/modules.html#the-module-search-path

Activating models
=================

That small bit of model code gives Django a lot of information. With it, Django
is able to:

* Create a database schema (``CREATE TABLE`` statements) for this app.
* Create a Python database-access API for accessing ``Poll`` and ``Choice`` objects.

But first we need to tell our project that the ``polls`` app is installed.

.. admonition:: Philosophy

    Django apps are "pluggable": You can use an app in multiple projects, and
    you can distribute apps, because they don't have to be tied to a given
    Django installation.

Edit the :file:`settings.py` file again, and change the
:setting:`INSTALLED_APPS` setting to include the string ``'polls'``. So
it'll look like this::

    INSTALLED_APPS = (
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.sites',
        'django.contrib.messages',
        'django.contrib.staticfiles',
        # Uncomment the next line to enable the admin:
        # 'django.contrib.admin',
        # Uncomment the next line to enable admin documentation:
        # 'django.contrib.admindocs',
        'polls',
    )

Now Django knows to include the ``polls`` app. Let's run another
command:

.. code-block:: bash

    python manage.py sql polls

You should see something similar to the following (the ``CREATE TABLE`` SQL
statements for the polls app):

.. code-block:: sql

    BEGIN;
    CREATE TABLE "polls_poll" (
        "id" serial NOT NULL PRIMARY KEY,
        "question" varchar(200) NOT NULL,
        "pub_date" timestamp with time zone NOT NULL
    );
    CREATE TABLE "polls_choice" (
        "id" serial NOT NULL PRIMARY KEY,
        "poll_id" integer NOT NULL REFERENCES "polls_poll" ("id") DEFERRABLE INITIALLY DEFERRED,
        "choice_text" varchar(200) NOT NULL,
        "votes" integer NOT NULL
    );
    COMMIT;

Note the following:

* The exact output will vary depending on the database you are using.

* Table names are automatically generated by combining the name of the app
  (``polls``) and the lowercase name of the model -- ``poll`` and
  ``choice``. (You can override this behavior.)

* Primary keys (IDs) are added automatically. (You can override this, too.)

* By convention, Django appends ``"_id"`` to the foreign key field name.
  (Yes, you can override this, as well.)

* The foreign key relationship is made explicit by a ``REFERENCES``
  statement.

* It's tailored to the database you're using, so database-specific field
  types such as ``auto_increment`` (MySQL), ``serial`` (PostgreSQL), or
  ``integer primary key`` (SQLite) are handled for you automatically. Same
  goes for quoting of field names -- e.g., using double quotes or single
  quotes. The author of this tutorial runs PostgreSQL, so the example
  output is in PostgreSQL syntax.

* The :djadmin:`sql` command doesn't actually run the SQL in your database -
  it just prints it to the screen so that you can see what SQL Django thinks
  is required. If you wanted to, you could copy and paste this SQL into your
  database prompt. However, as we will see shortly, Django provides an
  easier way of committing the SQL to the database.

If you're interested, also run the following commands:

* :djadmin:`python manage.py validate <validate>` -- Checks for any errors
  in the construction of your models.

* :djadmin:`python manage.py sqlcustom polls <sqlcustom>` -- Outputs any
  :ref:`custom SQL statements <initial-sql>` (such as table modifications or
  constraints) that are defined for the application.

* :djadmin:`python manage.py sqlclear polls <sqlclear>` -- Outputs the
  necessary ``DROP TABLE`` statements for this app, according to which
  tables already exist in your database (if any).

* :djadmin:`python manage.py sqlindexes polls <sqlindexes>` -- Outputs the
  ``CREATE INDEX`` statements for this app.

* :djadmin:`python manage.py sqlall polls <sqlall>` -- A combination of all
  the SQL from the :djadmin:`sql`, :djadmin:`sqlcustom`, and
  :djadmin:`sqlindexes` commands.

Looking at the output of those commands can help you understand what's actually
happening under the hood.

Now, run :djadmin:`syncdb` again to create those model tables in your database:

.. code-block:: bash

    python manage.py syncdb

The :djadmin:`syncdb` command runs the SQL from :djadmin:`sqlall` on your
database for all apps in :setting:`INSTALLED_APPS` that don't already exist in
your database. This creates all the tables, initial data and indexes for any
apps you've added to your project since the last time you ran syncdb.
:djadmin:`syncdb` can be called as often as you like, and it will only ever
create the tables that don't exist.

Read the :doc:`django-admin.py documentation </ref/django-admin>` for full
information on what the ``manage.py`` utility can do.

Playing with the API
====================

Now, let's hop into the interactive Python shell and play around with the free
API Django gives you. To invoke the Python shell, use this command:

.. code-block:: bash

    python manage.py shell

We're using this instead of simply typing "python", because :file:`manage.py`
sets the ``DJANGO_SETTINGS_MODULE`` environment variable, which gives Django
the Python import path to your :file:`settings.py` file.

.. admonition:: Bypassing manage.py

    If you'd rather not use :file:`manage.py`, no problem. Just set the
    ``DJANGO_SETTINGS_MODULE`` environment variable to ``mysite.settings`` and
    run ``python`` from the same directory :file:`manage.py` is in (or ensure
    that directory is on the Python path, so that ``import mysite`` works).

    For more information on all of this, see the :doc:`django-admin.py
    documentation </ref/django-admin>`.

Once you're in the shell, explore the :doc:`database API </topics/db/queries>`::

    >>> from polls.models import Poll, Choice   # Import the model classes we just wrote.

    # No polls are in the system yet.
    >>> Poll.objects.all()
    []

    # Create a new Poll.
    # Support for time zones is enabled in the default settings file, so
    # Django expects a datetime with tzinfo for pub_date. Use timezone.now()
    # instead of datetime.datetime.now() and it will do the right thing.
    >>> from django.utils import timezone
    >>> p = Poll(question="What's new?", pub_date=timezone.now())

    # Save the object into the database. You have to call save() explicitly.
    >>> p.save()

    # Now it has an ID. Note that this might say "1L" instead of "1", depending
    # on which database you're using. That's no biggie; it just means your
    # database backend prefers to return integers as Python long integer
    # objects.
    >>> p.id
    1

    # Access database columns via Python attributes.
    >>> p.question
    "What's new?"
    >>> p.pub_date
    datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>)

    # Change values by changing the attributes, then calling save().
    >>> p.question = "What's up?"
    >>> p.save()

    # objects.all() displays all the polls in the database.
    >>> Poll.objects.all()
    [<Poll: Poll object>]


Wait a minute. ``<Poll: Poll object>`` is, utterly, an unhelpful representation
of this object. Let's fix that by editing the polls model (in the
``polls/models.py`` file) and adding a
:meth:`~django.db.models.Model.__unicode__` method to both ``Poll`` and
``Choice``::

    class Poll(models.Model):
        # ...
        def __unicode__(self):
            return self.question

    class Choice(models.Model):
        # ...
        def __unicode__(self):
            return self.choice_text

It's important to add :meth:`~django.db.models.Model.__unicode__` methods to
your models, not only for your own sanity when dealing with the interactive
prompt, but also because objects' representations are used throughout Django's
automatically-generated admin.

.. admonition:: Why :meth:`~django.db.models.Model.__unicode__` and not
                :meth:`~django.db.models.Model.__str__`?

    If you're familiar with Python, you might be in the habit of adding
    :meth:`~django.db.models.Model.__str__` methods to your classes, not
    :meth:`~django.db.models.Model.__unicode__` methods. We use
    :meth:`~django.db.models.Model.__unicode__` here because Django models deal
    with Unicode by default. All data stored in your database is converted to
    Unicode when it's returned.

    Django models have a default :meth:`~django.db.models.Model.__str__` method
    that calls :meth:`~django.db.models.Model.__unicode__` and converts the
    result to a UTF-8 bytestring. This means that ``unicode(p)`` will return a
    Unicode string, and ``str(p)`` will return a normal string, with characters
    encoded as UTF-8.

    If all of this is gibberish to you, just remember to add
    :meth:`~django.db.models.Model.__unicode__` methods to your models. With any
    luck, things should Just Work for you.

Note these are normal Python methods. Let's add a custom method, just for
demonstration::

    import datetime
    from django.utils import timezone
    # ...
    class Poll(models.Model):
        # ...
        def was_published_recently(self):
            return self.pub_date >= timezone.now() - datetime.timedelta(days=1)

Note the addition of ``import datetime`` and ``from django.utils import
timezone``, to reference Python's standard :mod:`datetime` module and Django's
time-zone-related utilities in :mod:`django.utils.timezone`, respectively. If
you aren't familiar with time zone handling in Python, you can learn more in
the :doc:`time zone support docs </topics/i18n/timezones>`.

Save these changes and start a new Python interactive shell by running
``python manage.py shell`` again::

    >>> from polls.models import Poll, Choice

    # Make sure our __unicode__() addition worked.
    >>> Poll.objects.all()
    [<Poll: What's up?>]

    # Django provides a rich database lookup API that's entirely driven by
    # keyword arguments.
    >>> Poll.objects.filter(id=1)
    [<Poll: What's up?>]
    >>> Poll.objects.filter(question__startswith='What')
    [<Poll: What's up?>]

    # Get the poll that was published this year.
    >>> from django.utils import timezone
    >>> current_year = timezone.now().year
    >>> Poll.objects.get(pub_date__year=current_year)
    <Poll: What's up?>

    # Request an ID that doesn't exist, this will raise an exception.
    >>> Poll.objects.get(id=2)
    Traceback (most recent call last):
        ...
    DoesNotExist: Poll matching query does not exist. Lookup parameters were {'id': 2}

    # Lookup by a primary key is the most common case, so Django provides a
    # shortcut for primary-key exact lookups.
    # The following is identical to Poll.objects.get(id=1).
    >>> Poll.objects.get(pk=1)
    <Poll: What's up?>

    # Make sure our custom method worked.
    >>> p = Poll.objects.get(pk=1)
    >>> p.was_published_recently()
    True

    # Give the Poll a couple of Choices. The create call constructs a new
    # Choice object, does the INSERT statement, adds the choice to the set
    # of available choices and returns the new Choice object. Django creates
    # a set to hold the "other side" of a ForeignKey relation
    # (e.g. a poll's choices) which can be accessed via the API.
    >>> p = Poll.objects.get(pk=1)

    # Display any choices from the related object set -- none so far.
    >>> p.choice_set.all()
    []

    # Create three choices.
    >>> p.choice_set.create(choice_text='Not much', votes=0)
    <Choice: Not much>
    >>> p.choice_set.create(choice_text='The sky', votes=0)
    <Choice: The sky>
    >>> c = p.choice_set.create(choice_text='Just hacking again', votes=0)

    # Choice objects have API access to their related Poll objects.
    >>> c.poll
    <Poll: What's up?>

    # And vice versa: Poll objects get access to Choice objects.
    >>> p.choice_set.all()
    [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]
    >>> p.choice_set.count()
    3

    # The API automatically follows relationships as far as you need.
    # Use double underscores to separate relationships.
    # This works as many levels deep as you want; there's no limit.
    # Find all Choices for any poll whose pub_date is in this year
    # (reusing the 'current_year' variable we created above).
    >>> Choice.objects.filter(poll__pub_date__year=current_year)
    [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]

    # Let's delete one of the choices. Use delete() for that.
    >>> c = p.choice_set.filter(choice_text__startswith='Just hacking')
    >>> c.delete()

For more information on model relations, see :doc:`Accessing related objects
</ref/models/relations>`. For more on how to use double underscores to perform
field lookups via the API, see :ref:`Field lookups <field-lookups-intro>`. For
full details on the database API, see our :doc:`Database API reference
</topics/db/queries>`.

When you're comfortable with the API, read :doc:`part 2 of this tutorial
</intro/tutorial02>` to get Django's automatic admin working.
