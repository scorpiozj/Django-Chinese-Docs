=====================================
编写你的第一个 Django 程序 第4部分
=====================================

本教程上接 :doc:`教程 第3部分 </intro/tutorial03>` 。我们将
继续开发 Web-poll 应用并且关注在处理简单的窗体和优化我们的代码。

编写一个简单的窗体
===================

让我们把在上一篇教程中编写的 poll 的 detail 模板更新下，在模板中包含 HTML 的 ``<form>``
组件:

.. code-block:: html+django

    <h1>{{ poll.question }}</h1>

    {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

    <form action="{% url 'polls:vote' poll.id %}" method="post">
    {% csrf_token %}
    {% for choice in poll.choice_set.all %}
        <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}" />
        <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br />
    {% endfor %}
    <input type="submit" value="Vote" />
    </form>

简单的总结下:

* 上面的模板中为每个投票选项设置了一个单选按钮。每个单选按钮的
  ``value`` 是投票选项对应的 ID 。每个单选按钮的
  ``name`` 都是 ``"choice"``。这意味着，当有人选择了一个单选按钮并提交了表单，将会发送
  的 POST 数据是 ``choice=3``。这是 HTML 表单中的基本概念。

* 我们将 form 的 ``action`` 设置为 ``{% url 'polls:vote' poll.id %}``，以及设置了
  ``method="post"`` 。使用 ``method="post"`` ( 而不是 ``method="get"``) 是非常重要的，因为这种提交表单的方式会改变服务器端的数据。
  当你创建一个表单为了修改服务器端的数据时，请使用
  ``method="post"`` 。这不是 Django 特定的技巧；这是优秀的 Web 开发实践。

* ``forloop.counter`` 表示 :ttag:`for` 标签在循环中已经循环过的次数

* 由于我们要创建一个POST form ( 具有修改数据的功能
  )，我们需要担心跨站点请求伪造 （ Cross Site Request Forgeries ）。
  值得庆幸的是，你不必太担心这一点，因为 Django 自带了一个非常容易使用的系统来防御它。
  总之，所有的 POST form 针对内部的 URLs 时都应该使用 
  :ttag:`{% csrf_token %}<csrf_token>` 模板标签。

现在，让我们来创建一个 Django 视图来处理提交的数据。
记得吗？在 :doc:`教程 第3部分 </intro/tutorial03>` 中，我们为 polls 应用创建了一个
URLconf 配置中包含有这一行代码::

    url(r'^(?P<poll_id>\d+)/vote/$', views.vote, name='vote'),

我们还创建了一个虚拟实现的 ``vote()`` 函数。让我们创建一个真实版本吧。在
``polls/views.py`` 中添加如下代码::

    from django.shortcuts import get_object_or_404, render
    from django.http import HttpResponseRedirect, HttpResponse
    from django.core.urlresolvers import reverse
    from polls.models import Choice, Poll
    # ...
    def vote(request, poll_id):
        p = get_object_or_404(Poll, pk=poll_id)
        try:
            selected_choice = p.choice_set.get(pk=request.POST['choice'])
        except (KeyError, Choice.DoesNotExist):
            # Redisplay the poll voting form.
            return render(request, 'polls/detail.html', {
                'poll': p,
                'error_message': "You didn't select a choice.",
            })
        else:
            selected_choice.votes += 1
            selected_choice.save()
            # Always return an HttpResponseRedirect after successfully dealing
            # with POST data. This prevents data from being posted twice if a
            # user hits the Back button.
            return HttpResponseRedirect(reverse('polls:results', args=(p.id,)))

在这代码中有些内容还未在本教程中提到过:

* :attr:`request.POST <django.http.HttpRequest.POST>` 是一个类似字典的对象，可以让你
  通过关键字名称来获取提交的数据。在本例中，
  ``request.POST['choice']`` 返回了所选择的投票项目的 ID ，以字符串的形式。
  :attr:`request.POST <django.http.HttpRequest.POST>` 的值永远是字符串形式的。

  请注意 Django 也同样的提供了通过 :attr:`request.GET
  <django.http.HttpRequest.GET>` 获取 GET 数据的方法 --
  但是在代码中我们明确的使用了 :attr:`request.POST
  <django.http.HttpRequest.POST>` 方法，以确保数据是通过 POST 方法来修改的。

* 如果 ``choice`` 未在 POST 数据中提供 ``request.POST['choice']`` 将抛出 :exc:`~exceptions.KeyError`
  当未给定 ``choice`` 对象时上面的代码若检测到抛出的是
  :exc:`~exceptions.KeyError` 异常就会向 poll 显示一条错误信息。

* 在增加了投票选项的统计数后，代码返回一个 
  :class:`~django.http.HttpResponseRedirect` 对象而不是常见的
  :class:`~django.http.HttpResponse` 对象。
  :class:`~django.http.HttpResponseRedirect` 对象需要一个参数：用户将被重定向的 URL
  (请继续看下去在这情况下我们是如何构造 URL ) 。

  就像上面用 Python 作的注释那样，当成功的处理了 POST 数据后你应该总是返回一个
  :class:`~django.http.HttpResponseRedirect` 对象。
  这个技巧不是特定于 Django 的；它是优秀的 Web 开发实践。

* 在本例中，我们在 :class:`~django.http.HttpResponseRedirect` 的构造方法中使用了 :func:`~django.core.urlresolvers.reverse` 函数。
  此函数有助于避免在视图中硬编码 URL 的功能。它指定了我们想要的跳转的视图函数名以及视图函数中
  URL 模式相应的可变参数。在本例中，我们使用了教程 第3部分中的 URLconf 配置，
  :func:`~django.core.urlresolvers.reverse` 将会返回类似如下所示的字符串
  ::

    '/polls/3/results/'

  ... 在此 ``3`` 就是 ``p.id`` 的值。该重定向 URL 会调用
  ``'results'`` 视图并显示最终页面。

正如在教程 第3部分提到的，``request`` 是一个 :class:`~django.http.HttpRequest`
对象。想了解 :class:`~django.http.HttpRequest` 对象更多的内容，请参阅
:doc:`request 和 response 文档 </ref/request-response>` 。

当有人投票后，``vote()`` 视图会重定向到投票结果页。让我们来编写这个视图
::

    def results(request, poll_id):
        poll = get_object_or_404(Poll, pk=poll_id)
        return render(request, 'polls/results.html', {'poll': poll})

这几乎和 :doc:`教程 第3部分 </intro/tutorial03>` 中的 ``detail()`` 视图完全一样。
</intro/tutorial03>` 。唯一的区别就是模板名称。 稍后我们会解决这个冗余问题。

现在，创建一个 ``polls/results.html`` 模板:

.. code-block:: html+django

    <h1>{{ poll.question }}</h1>

    <ul>
    {% for choice in poll.choice_set.all %}
        <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
    {% endfor %}
    </ul>

    <a href="{% url 'polls:detail' poll.id %}">Vote again?</a>

现在，在浏览器中访问 ``/polls/1/`` 并完成投票。每次投票后你将会看到结果页数据都有更新。
如果你没有选择投票选项就提交了，将会看到错误的信息。

使用通用视图：优化代码
======================================

The ``detail()`` (from :doc:`Tutorial 3 </intro/tutorial03>`) and ``results()``
views are stupidly simple -- and, as mentioned above, redundant. The ``index()``
view (also from Tutorial 3), which displays a list of polls, is similar.

These views represent a common case of basic Web development: getting data from
the database according to a parameter passed in the URL, loading a template and
returning the rendered template. Because this is so common, Django provides a
shortcut, called the "generic views" system.

Generic views abstract common patterns to the point where you don't even need
to write Python code to write an app.

Let's convert our poll app to use the generic views system, so we can delete a
bunch of our own code. We'll just have to take a few steps to make the
conversion. We will:

1. Convert the URLconf.

2. Delete some of the old, unneeded views.

3. Fix up URL handling for the new views.

Read on for details.

.. admonition:: Why the code-shuffle?

    Generally, when writing a Django app, you'll evaluate whether generic views
    are a good fit for your problem, and you'll use them from the beginning,
    rather than refactoring your code halfway through. But this tutorial
    intentionally has focused on writing the views "the hard way" until now, to
    focus on core concepts.

    You should know basic math before you start using a calculator.

Amend URLconf
-------------

First, open the ``polls/urls.py`` URLconf and change it like so::

    from django.conf.urls import patterns, url
    from django.views.generic import DetailView, ListView
    from polls.models import Poll

    urlpatterns = patterns('',
        url(r'^$',
            ListView.as_view(
                queryset=Poll.objects.order_by('-pub_date')[:5],
                context_object_name='latest_poll_list',
                template_name='polls/index.html'),
            name='index'),
        url(r'^(?P<pk>\d+)/$',
            DetailView.as_view(
                model=Poll,
                template_name='polls/detail.html'),
            name='detail'),
        url(r'^(?P<pk>\d+)/results/$',
            DetailView.as_view(
                model=Poll,
                template_name='polls/results.html'),
            name='results'),
        url(r'^(?P<poll_id>\d+)/vote/$', 'polls.views.vote', name='vote'),
    )

Amend views
-----------

We're using two generic views here:
:class:`~django.views.generic.list.ListView` and
:class:`~django.views.generic.detail.DetailView`. Respectively, those
two views abstract the concepts of "display a list of objects" and
"display a detail page for a particular type of object."

* Each generic view needs to know what model it will be acting
  upon. This is provided using the ``model`` parameter.

* The :class:`~django.views.generic.detail.DetailView` generic view
  expects the primary key value captured from the URL to be called
  ``"pk"``, so we've changed ``poll_id`` to ``pk`` for the generic
  views.

By default, the :class:`~django.views.generic.detail.DetailView` generic
view uses a template called ``<app name>/<model name>_detail.html``.
In our case, it'll use the template ``"polls/poll_detail.html"``. The
``template_name`` argument is used to tell Django to use a specific
template name instead of the autogenerated default template name. We
also specify the ``template_name`` for the ``results`` list view --
this ensures that the results view and the detail view have a
different appearance when rendered, even though they're both a
:class:`~django.views.generic.detail.DetailView` behind the scenes.

Similarly, the :class:`~django.views.generic.list.ListView` generic
view uses a default template called ``<app name>/<model
name>_list.html``; we use ``template_name`` to tell
:class:`~django.views.generic.list.ListView` to use our existing
``"polls/index.html"`` template.

In previous parts of the tutorial, the templates have been provided
with a context that contains the ``poll`` and ``latest_poll_list``
context variables. For ``DetailView`` the ``poll`` variable is provided
automatically -- since we're using a Django model (``Poll``), Django
is able to determine an appropriate name for the context variable.
However, for ListView, the automatically generated context variable is
``poll_list``. To override this we provide the ``context_object_name``
option, specifying that we want to use ``latest_poll_list`` instead.
As an alternative approach, you could change your templates to match
the new default context variables -- but it's a lot easier to just
tell Django to use the variable you want.

You can now delete the ``index()``, ``detail()`` and ``results()`` views from
``polls/views.py``. We don't need them anymore -- they have been replaced by
generic views. You can also delete the import for ``HttpResponse``, which is no
longer required.

Run the server, and use your new polling app based on generic views.

For full details on generic views, see the :doc:`generic views documentation
</topics/class-based-views/index>`.

When you're comfortable with forms and generic views, read :doc:`part 5 of this
tutorial</intro/tutorial05>` to learn about testing our polls app.
