=====================================
编写你的第一个 Django 程序 第2部分
=====================================

本教程从 :doc:`Tutorial 1 </intro/tutorial01>` 开始。
我们将继续开发 Web-poll 应用，并且专注在 Django 的
自动生成的管理网站上。

.. admonition:: 哲理

    为你的员工或客户生成添加、修改和删除内容的管理性网站是个单调乏味的工作。
    出于这个原因，Django 根据模型完全自动化创建管理界面。

    Django 是在新闻编辑室环境下编写的，“内容发表者”和“公共”网站之间有
    非常明显的界线。网站管理员使用这个系统来添加新闻、事件、体育成绩等等，
    而这些内容会在公共网站上显示出来。Django 解决了为网站管理员创建统一
    的管理界面用以编辑内容的问题。

    管理界面不是让网站访问者使用的。它是为网站管理员准备的。

启用管理网站
=======================

默认情况下 Django 管理网站是不启用的 -- 它是可选的。
要启用管理网站，需要做三件事：

* 在 :setting:`INSTALLED_APPS` 设置中取消 ``"django.contrib.admin"`` 的注释。

* 运行 ``python manage.py syncdb`` 命令。既然你添加了新应用到
  :setting:`INSTALLED_APPS` 中，数据库表就需要更新。

* 编辑你的 ``mysite/urls.py`` 文件并且将有关管理的行取消注释  -- 共有三行取消了注释。该文件是 URLconf ；我们将在下一个教程中深入探讨 URLconfs 。现在，你需要知道的是它将 URL 映射到应用。最后你拥有的 ``urls.py`` 文件看起来像这样:

  .. parsed-literal::

      from django.conf.urls import patterns, include, url

      # Uncomment the next two lines to enable the admin:
      **from django.contrib import admin**
      **admin.autodiscover()**

      urlpatterns = patterns('',
          # Examples:
          # url(r'^$', '{{ project_name }}.views.home', name='home'),
          # url(r'^{{ project_name }}/', include('{{ project_name }}.foo.urls')),

          # Uncomment the admin/doc line below to enable admin documentation:
          # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

          # Uncomment the next line to enable the admin:
          **url(r'^admin/', include(admin.site.urls)),**
      )

  ( 粗体显示的行就是那些需要取消注释的行。)

启动开发服务器
============================

让我们启动开发服务器并浏览管理网站。

回想下教程的第一部分，像如下所示启动你的开发服务器：

.. code-block:: bash

    python manage.py runserver

现在，打开一个浏览器并在本地域名上访问 "/admin/" -- 例如
http://127.0.0.1:8000/admin/ 。你将看到管理员的登录界面：

.. image:: _images/admin01.png
   :alt: Django admin login screen

.. admonition:: 和你看到的不一样？

    如果看到这，而不是上面的登录界面，那你应该得到一个类似如下所示的错误页面报告：

        ImportError at /admin/
        cannot import name patterns
        ...

    那么你很可能使用的 Django 版本不符合本教程的版本。
    你可以切换到对应的旧版本教程去或者更新到较新的 Django 版本。

进入管理网站
====================

现在尝试登录进去。（还记得吗？在本教程的第一部分时你创建过一个超级用户的帐号。如果你没有创建或忘记了密码，你可以
:ref:`另外创建一个 <topics-auth-creating-superusers>` 。） 你将看到 Djaong 的管理索引页：

.. image:: _images/admin02t.png
   :alt: Django admin index page

你将看到一些可编辑的内容，包括 groups ，users 和 sites 。这些都是 Django 默认情况下自带的核心功能。

使 poll 应用的数据在管理网站中可编辑
=========================================

但是 poll 应用在哪？ 它可是没有在管理网站的首页上显示啊。

只需要做一件事：我们需要告诉管理网站 ``Poll``
对象要有一个管理界面。为此，我们在你的 ``polls`` 目录下创建一个名为
``admin.py`` 的文件，并添加如下内容：::

    from django.contrib import admin
    from polls.models import Poll

    admin.site.register(Poll)

你需要重启开发服务器才能看到变化。通常情况下，你每次修改过一个文件后开发
服务器都会自动载入，但是创建一个新文件却不会触发自动载入的逻辑。

探索管理功能
====================================

现在我们已经注册了 ``Poll`` ，那 Django 就知道了要在管理网站的首页上显示出来：

.. image:: _images/admin03t.png
   :alt: Django admin index page, now with polls displayed

点击 "Polls" 。现在你在 polls 的 “更改列表” 页。该页
显示了数据库中所有的 polls 可让你选中一个进行编辑。
有个 "What's up?" poll 是我们在第一个教程中创建的：

.. image:: _images/admin04t.png
   :alt: Polls change list page

点击这个"What's up?" 的 poll 进行编辑：

.. image:: _images/admin05t.png
   :alt: Editing form for poll object

这有些注意事项：

* 这的表单是根据 Poll 模型自动生成的。

* 不同模型的字段类型 (:class:`~django.db.models.DateTimeField`,
  :class:`~django.db.models.CharField`) 会对应的相应的 HTML 输入控件。
  每一种类型的字段 Djaong 管理网站都知道如何显示它们。

* 每个 :class:`~django.db.models.DateTimeField` 都会有个方便的 JavaScript
  快捷方式。日期有一个 "Today" 快捷方式和弹出式日历，而时间有个 "Now"
  快捷方式和一个列出了常用时间选项的弹出式窗口。

在页面的底部还为你提供了几个选项：

* Save -- 保存更改并返回到当前类型的对象的更改列表页面。

* Save and continue editing -- 保存更改并重新载入当前对象的管理界面。

* Save and add another -- 保存更改并载入当前对象类型的新的空白表单。

* Delete -- 显示删除确认页。

如果 "Date published" 的值与你在第一部分教程时创建的 poll 的时间不符，这可能
意味着你忘记了将 :setting:`TIME_ZONE` 设置成正确的值了。修改正确后再重启载入页面
来检查值是否正确。

分别点击 "Today" 和 "Now" 快捷方式来修改 "Date published" 的值。
然后点击 "Save and continue editing" 。最后点击右上角的 "History" 。
你将看到一页列出了通过 Django 管理界面对此对象所做的全部更改的清单的页面，
包含有时间戳和修改人的姓名等信息：

.. image:: _images/admin06t.png
   :alt: History page for poll object

自定义管理表单
========================

花些时间感叹一下吧，你没写什么代码就拥有了这一切。通过
``admin.site.register(Poll)`` 注册了 Poll 模型，Django 就能构造一个默认的
表单。通常情况下，你将要自定义管理表单的外观和功能。这样的话你就需要在注册对象
时告诉 Django 对应的配置。 

让我们来看看如何在编辑表单上给字段重新排序。将 ``admin.site.register(Poll)`` 这行替换成：::

    class PollAdmin(admin.ModelAdmin):
        fields = ['pub_date', 'question']

    admin.site.register(Poll, PollAdmin)

你将遵循这个模式 -- 创建一个模型的管理对象，将它作为 ``admin.site.register()``
方法的第二个参数传入 -- 当你需要为一个对象做管理界面配置的时候。

上面那特定的更改使得 "Publication date" 字段在 "Question" 字段之前:

.. image:: _images/admin07.png
   :alt: Fields have been reordered

仅有两个字段不会令你印象深刻，但是对于有许多字段的管理表单时，选择一个直观
的排序方式是一个重要的实用细节。

刚才所说的有许多字段的表单，你可能想将表单中的字段分割成 fieldsets ：::

    class PollAdmin(admin.ModelAdmin):
        fieldsets = [
            (None,               {'fields': ['question']}),
            ('Date information', {'fields': ['pub_date']}),
        ]

    admin.site.register(Poll, PollAdmin)

在 ``fieldsets`` 中每一个 tuple 的第一个元素就是 fieldset 的标题。 
下面是我们表单现在的样子：

.. image:: _images/admin08t.png
   :alt: Form has fieldsets now

你可以为每个 fieldset 指定 THML 样式类。Django 提供了一个 
``"collapse"`` 样式类用于显示初始时是收缩的 fieldset 。
当你有一个包含一些不常用的长窗体时这是非常有用的 ::

        class PollAdmin(admin.ModelAdmin):
            fieldsets = [
                (None,               {'fields': ['question']}),
                ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
            ]

.. image:: _images/admin09.png
   :alt: Fieldset is initially collapsed

Adding related objects
======================

OK, we have our Poll admin page. But a ``Poll`` has multiple ``Choices``, and
the admin page doesn't display choices.

Yet.

There are two ways to solve this problem. The first is to register ``Choice``
with the admin just as we did with ``Poll``. That's easy::

    from polls.models import Choice

    admin.site.register(Choice)

Now "Choices" is an available option in the Django admin. The "Add choice" form
looks like this:

.. image:: _images/admin10.png
   :alt: Choice admin page

In that form, the "Poll" field is a select box containing every poll in the
database. Django knows that a :class:`~django.db.models.ForeignKey` should be
represented in the admin as a ``<select>`` box. In our case, only one poll
exists at this point.

Also note the "Add Another" link next to "Poll." Every object with a
``ForeignKey`` relationship to another gets this for free. When you click "Add
Another," you'll get a popup window with the "Add poll" form. If you add a poll
in that window and click "Save," Django will save the poll to the database and
dynamically add it as the selected choice on the "Add choice" form you're
looking at.

But, really, this is an inefficient way of adding ``Choice`` objects to the system.
It'd be better if you could add a bunch of Choices directly when you create the
``Poll`` object. Let's make that happen.

Remove the ``register()`` call for the ``Choice`` model. Then, edit the ``Poll``
registration code to read::

    from django.contrib import admin
    from polls.models import Choice, Poll

    class ChoiceInline(admin.StackedInline):
        model = Choice
        extra = 3

    class PollAdmin(admin.ModelAdmin):
        fieldsets = [
            (None,               {'fields': ['question']}),
            ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
        ]
        inlines = [ChoiceInline]

    admin.site.register(Poll, PollAdmin)

This tells Django: "``Choice`` objects are edited on the ``Poll`` admin page. By
default, provide enough fields for 3 choices."

Load the "Add poll" page to see how that looks, you may need to restart your development server:

.. image:: _images/admin11t.png
   :alt: Add poll page now has choices on it

It works like this: There are three slots for related Choices -- as specified
by ``extra`` -- and each time you come back to the "Change" page for an
already-created object, you get another three extra slots.

At the end of the three current slots you will find an "Add another Choice"
link.  If you click on it, a new slot will be added. If you want to remove the
added slot, you can click on the X to the top right of the added slot. Note
that you can't remove the original three slots. This image shows an added slot:

.. image:: _images/admin15t.png
   :alt: Additional slot added dynamically

One small problem, though. It takes a lot of screen space to display all the
fields for entering related ``Choice`` objects. For that reason, Django offers a
tabular way of displaying inline related objects; you just need to change
the ``ChoiceInline`` declaration to read::

    class ChoiceInline(admin.TabularInline):
        #...

With that ``TabularInline`` (instead of ``StackedInline``), the
related objects are displayed in a more compact, table-based format:

.. image:: _images/admin12t.png
   :alt: Add poll page now has more compact choices

Note that there is an extra "Delete?" column that allows removing rows added
using the "Add Another Choice" button and rows that have already been saved.

Customize the admin change list
===============================

Now that the Poll admin page is looking good, let's make some tweaks to the
"change list" page -- the one that displays all the polls in the system.

Here's what it looks like at this point:

.. image:: _images/admin04t.png
   :alt: Polls change list page

By default, Django displays the ``str()`` of each object. But sometimes it'd be
more helpful if we could display individual fields. To do that, use the
``list_display`` admin option, which is a tuple of field names to display, as
columns, on the change list page for the object::

    class PollAdmin(admin.ModelAdmin):
        # ...
        list_display = ('question', 'pub_date')

Just for good measure, let's also include the ``was_published_recently`` custom
method from Tutorial 1::

    class PollAdmin(admin.ModelAdmin):
        # ...
        list_display = ('question', 'pub_date', 'was_published_recently')

Now the poll change list page looks like this:

.. image:: _images/admin13t.png
   :alt: Polls change list page, updated

You can click on the column headers to sort by those values -- except in the
case of the ``was_published_recently`` header, because sorting by the output
of an arbitrary method is not supported. Also note that the column header for
``was_published_recently`` is, by default, the name of the method (with
underscores replaced with spaces), and that each line contains the string
representation of the output.

You can improve that by giving that method (in ``models.py``) a few
attributes, as follows::

    class Poll(models.Model):
        # ...
        def was_published_recently(self):
            return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
        was_published_recently.admin_order_field = 'pub_date'
        was_published_recently.boolean = True
        was_published_recently.short_description = 'Published recently?'

Edit your admin.py file again and add an improvement to the Poll change list page: Filters. Add the
following line to ``PollAdmin``::

    list_filter = ['pub_date']

That adds a "Filter" sidebar that lets people filter the change list by the
``pub_date`` field:

.. image:: _images/admin14t.png
   :alt: Polls change list page, updated

The type of filter displayed depends on the type of field you're filtering on.
Because ``pub_date`` is a :class:`~django.db.models.DateTimeField`, Django
knows to give appropriate filter options: "Any date," "Today," "Past 7 days,"
"This month," "This year."

This is shaping up well. Let's add some search capability::

    search_fields = ['question']

That adds a search box at the top of the change list. When somebody enters
search terms, Django will search the ``question`` field. You can use as many
fields as you'd like -- although because it uses a ``LIKE`` query behind the
scenes, keep it reasonable, to keep your database happy.

Finally, because ``Poll`` objects have dates, it'd be convenient to be able to
drill down by date. Add this line::

    date_hierarchy = 'pub_date'

That adds hierarchical navigation, by date, to the top of the change list page.
At top level, it displays all available years. Then it drills down to months
and, ultimately, days.

Now's also a good time to note that change lists give you free pagination. The
default is to display 100 items per page. Change-list pagination, search boxes,
filters, date-hierarchies and column-header-ordering all work together like you
think they should.

Customize the admin look and feel
=================================

Clearly, having "Django administration" at the top of each admin page is
ridiculous. It's just placeholder text.

That's easy to change, though, using Django's template system. The Django admin
is powered by Django itself, and its interfaces use Django's own template
system.

.. _ref-customizing-your-projects-templates:

Customizing your *project's* templates
--------------------------------------

Create a ``templates`` directory in your project directory. Templates can
live anywhere on your filesystem that Django can access. (Django runs as
whatever user your server runs.) However, keeping your templates within the
project is a good convention to follow.

By default, :setting:`TEMPLATE_DIRS` is empty. So, let's add a line to it, to
tell Django where our templates live::

    TEMPLATE_DIRS = (
        '/path/to/mysite/templates', # Change this to your own directory.
    )

Now copy the template ``admin/base_site.html`` from within the default Django
admin template directory in the source code of Django itself
(``django/contrib/admin/templates``) into an ``admin`` subdirectory of
whichever directory you're using in :setting:`TEMPLATE_DIRS`. For example, if
your :setting:`TEMPLATE_DIRS` includes ``'/path/to/mysite/templates'``, as
above, then copy ``django/contrib/admin/templates/admin/base_site.html`` to
``/path/to/mysite/templates/admin/base_site.html``. Don't forget that
``admin`` subdirectory.

.. admonition:: Where are the Django source files?

    If you have difficulty finding where the Django source files are located
    on your system, run the following command:

    .. code-block:: bash

        python -c "
        import sys
        sys.path = sys.path[1:]
        import django
        print(django.__path__)"

Then, just edit the file and replace the generic Django text with your own
site's name as you see fit.

This template file contains lots of text like ``{% block branding %}``
and ``{{ title }}``. The ``{%`` and ``{{`` tags are part of Django's
template language. When Django renders ``admin/base_site.html``, this
template language will be evaluated to produce the final HTML page.
Don't worry if you can't make any sense of the template right now --
we'll delve into Django's templating language in Tutorial 3.

Note that any of Django's default admin templates can be overridden. To
override a template, just do the same thing you did with ``base_site.html`` --
copy it from the default directory into your custom directory, and make
changes.

Customizing your *application's* templates
------------------------------------------

Astute readers will ask: But if :setting:`TEMPLATE_DIRS` was empty by default,
how was Django finding the default admin templates? The answer is that, by
default, Django automatically looks for a ``templates/`` subdirectory within
each application package, for use as a fallback (don't forget that
``django.contrib.admin`` is an application).

Our poll application is not very complex and doesn't need custom admin
templates. But if it grew more sophisticated and required modification of
Django's standard admin templates for some of its functionality, it would be
more sensible to modify the *application's* templates, rather than those in the
*project*. That way, you could include the polls application in any new project
and be assured that it would find the custom templates it needed.

See the :ref:`template loader documentation <template-loaders>` for more
information about how Django finds its templates.

Customize the admin index page
==============================

On a similar note, you might want to customize the look and feel of the Django
admin index page.

By default, it displays all the apps in :setting:`INSTALLED_APPS` that have been
registered with the admin application, in alphabetical order. You may want to
make significant changes to the layout. After all, the index is probably the
most important page of the admin, and it should be easy to use.

The template to customize is ``admin/index.html``. (Do the same as with
``admin/base_site.html`` in the previous section -- copy it from the default
directory to your custom template directory.) Edit the file, and you'll see it
uses a template variable called ``app_list``. That variable contains every
installed Django app. Instead of using that, you can hard-code links to
object-specific admin pages in whatever way you think is best. Again,
don't worry if you can't understand the template language -- we'll cover that
in more detail in Tutorial 3.

When you're comfortable with the admin site, read :doc:`part 3 of this tutorial
</intro/tutorial03>` to start working on public poll views.
