=====================================
编写你的第一个 Django 程序 第3部分
=====================================

本教程上接 :doc:`教程 第2部分 </intro/tutorial02>` 。我们将继续
开发 Web-poll 应用并且专注在创建公共界面 --  "视图 （views ）"。

哲理
==========

在 Django 应用程序中，视图是一“类”具有特定功能和模板的网页。
例如，在一个博客应用程序中，你可能会有以下视图：

* 博客首页 -- 显示最新发表的博客。

* 博客详细页面 -- 一篇博客的独立页面。

* 基于年份的归档页 -- 显示给定年份中发表博客的所有月份。

* 基于月份的归档页 -- 显示给定月份中发表博客的所有日期。

* 基于日期的归档页 -- 显示给定日期中发表的所有的博客。

* 评论功能 -- 为一篇给定博客发表评论。

在我们的 poll 应用程序中，将有以下四个视图：

* Poll "index" 页 -- 显示最新发布的民意调查。

* Poll "detail" 页 -- 显示一项民意调查的具体问题，不显示该项的投票结果但可以进行投票的 form 。

* Poll "results" 页 -- 显示一项给定的民意调查的投票结果。

* 投票功能 -- 为一项给定的民意调查处理投票选项。

在 Django 中，网页及其他内容是由视图来展现的。而每个视图就是一个简单的 Python 函数（或方法，
对于基于类的视图情况下）。Django 会通过检查所请求的 URL （确切地说是域名之后的那部分 URL）来匹配一个视图。

平时你上网的时候可能会遇到像
"ME2/Sites/dirmod.asp?sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B" 这种如此美丽的 URL。
但是你会很高兴知道 Django 允许我们使用比那优雅的 *URL 模式* 来展现 URL。

URL 模式就是一个简单的一般形式的 URL - 比如:
``/newsarchive/<year>/<month>/``.

Django 是通过 'URLconfs' 从 URL 获取到视图的。而
URLconf 是将 URL 模式 ( 由正则表达式来描述的 ) 映射到视图的一种配置。

本教程中介绍了使用 URLconfs 的基本指令，你可以查阅
:mod:`django.core.urlresolvers` 来获取更多信息。

编写你的第一个视图
=====================

让我们编写第一个视图。打开文件 ``polls/views.py``
并在其中输入以下 Python 代码 ::

    from django.http import HttpResponse

    def index(request):
        return HttpResponse("Hello, world. You're at the poll index.")

在 Django 中这可能是最简单的视图了。为了调用这个视图，我们需要将它映射到一个 URL
-- 为此我们需要配置一个URLconf 。

在 polls 目录下创建一个名为 ``urls.py`` 的 URLconf 文档。
你的应用目录现在看起来像这样 ::

    polls/
        __init__.py
        admin.py
        models.py
        tests.py
        urls.py
        views.py

在 ``polls/urls.py`` 文件中输入以下代码： ::

    from django.conf.urls import patterns, url

    from polls import views

    urlpatterns = patterns('',
        url(r'^$', views.index, name='index')
    )

下一步是将 ``polls.urls`` 模块指向 root URLconf 。在
``mysite/urls.py`` 中插入一个 :func:`~django.conf.urls.include` 方法，最后的样子如下所示 ::

    from django.conf.urls import patterns, include, url

    from django.contrib import admin
    admin.autodiscover()

    urlpatterns = patterns('',
        url(r'^polls/', include('polls.urls')),
        url(r'^admin/', include(admin.site.urls)),
    )

现在你在 URLconf 中配置了 `index` 视图。通过浏览器访问
http://localhost:8000/polls/ ，如同你在 ``index`` 视图中定义的一样，你将看到
"*Hello, world. You're at the poll index.*" 文字。

:func:`~django.conf.urls.url` 函数有四个参数，两个必须的： ``regex`` 和 ``view``， 两个可选的： ``kwargs``， 以及 ``name``。
接下来，来探讨下这些参数的意义。

:func:`~django.conf.urls.url` 参数: regex
---------------------------------------------

`regex` 是 `regular expression` 的简写，这是字符串中的模式匹配的一种语法，
在 Django 中就是是 url 匹配模式。
Django 将请求的 URL 从上至下依次匹配列表中的正则表达式，直到匹配到一个为止。

需要注意的是，这些正则表达式不会匹配 GET 和 POST 参数，以及域名。
例如：针对 ``http://www.example.com/myapp/`` 这一请求，URLconf 将只查找 ``myapp/``。而在
``http://www.example.com/myapp/?page=3`` 中 URLconf 也仅查找 ``myapp/`` 。

如果你需要正则表达式方面的帮助，请参阅 `Wikipedia's entry`_ 和本文档中的 :mod:`re` 模块。
此外，O'Reilly 出版的由 Jeffrey Friedl 著的 "Mastering Regular Expressions" 也是不错的。
但是，实际上，你并不需要成为一个正则表达式的专家，仅仅需要知道如何捕获简单的模式。
事实上，复杂的正则表达式会降低查找性能，因此你不能完全依赖正则表达式的功能。

最后有个性能上的提示：这些正则表达式在 URLconf 模块第一次加载时会被编译。
因此它们速度超快 ( 像上面提到的那样只要查找的不是太复杂 )。

.. _Wikipedia's entry: http://en.wikipedia.org/wiki/Regular_expression

:func:`~django.conf.urls.url` 参数： view
--------------------------------------------

当 Django 匹配了一个正则表达式就会调用指定的视图功能，包含一个
:class:`~django.http.HttpRequest` 实例作为第一个参数和正则表达式
“捕获” 的一些值的作为其他参数。
如果使用简单的正则捕获，将按顺序位置传参数；如果按命名的正则捕获，将按关键字传参数值。
有关这一点我们会给出一个例子。

:func:`~django.conf.urls.url` 参数： kwargs
----------------------------------------------

任意关键字参数可传一个字典至目标视图。在本教程中，我们并不打算使用 Django 这一特性。

:func:`~django.conf.urls.url` 参数： name
---------------------------------------------

命名你的 URL ，让你在 Django 的其他地方明确地引用它，特别是在模板中。
这一强大的功能可允许你通过一个文件就可全局修改项目中的 URL 模式。

编写更多视图
==================

现在让我们添加一些视图到 ``polls/views.py`` 中去。这些视图与之前的略有不同，因为
它们有一个参数：::

    def detail(request, poll_id):
        return HttpResponse("You're looking at poll %s." % poll_id)

    def results(request, poll_id):
        return HttpResponse("You're looking at the results of poll %s." % poll_id)

    def vote(request, poll_id):
        return HttpResponse("You're voting on poll %s." % poll_id)

将新视图按如下所示的 :func:`~django.conf.urls.url` 方法添加到
``polls.urls`` 模块中去：::

    from django.conf.urls import patterns, url

    from polls import views

    urlpatterns = patterns('',
        # ex: /polls/
        url(r'^$', views.index, name='index'),
        # ex: /polls/5/
        url(r'^(?P<poll_id>\d+)/$', views.detail, name='detail'),
        # ex: /polls/5/results/
        url(r'^(?P<poll_id>\d+)/results/$', views.results, name='results'),
        # ex: /polls/5/vote/
        url(r'^(?P<poll_id>\d+)/vote/$', views.vote, name='vote'),
    )

在你的浏览器中访问 http://localhost:8000/polls/34/ 。将运行 ``detail()``
方法并且显示你在 URL 中提供的任意 ID 。试着访问 http://localhost:8000/polls/34/results/ 
和 http://localhost:8000/polls/34/vote/ -- 将会显示对应的结果页及投票页。

当有人访问你的网站页面如 “ /polls/34/ ” 时，Django 会加载 ``mysite.urls`` 模块，这是因为
:setting:`ROOT_URLCONF` 设置指向它。接着在该模块中寻找名为``urlpatterns`` 的变量并依次匹配其中的正则表达式。
:func:`~django.conf.urls.include` 可让我们便利地引用其他 URLconfs 。请注意
:func:`~django.conf.urls.include` 中的正则表达式没有 ``$`` (字符串结尾的匹配符
match character) 而尾部是一个反斜杠。当 Django 解析
:func:`~django.conf.urls.include` 时，它截取匹配的 URL 那部分而把剩余的字符串交由
加载进来的 URLconf 作进一步处理。


:func:`~django.conf.urls.include` 背后隐藏的想法是使 URLs 即插即用。
由于 polls 在自己的 URLconf(``polls/urls.py``) 中，因此它们可以被放置在 "/polls/" 路径下，或
"/fun_polls/" 路径下，或 "/content/polls/" 路径下，或者其他根路径，而应用仍可以运行。

以下是当用户访问 "/polls/34/" 路径时系统中将发生的事：

* Django 将寻找 ``'^polls/'`` 的匹配

* 接着，Django 截取匹配文本 (``"polls/"``) 后剩余的文本
  -- ``"34/"`` -- 传递到 'polls.urls' URLconf 中作进一步处理，
  再将匹配 ``r'^(?P<poll_id>\d+)/$'`` 的结果作为参数传给 ``detail()`` 视图 ::

    detail(request=<HttpRequest object>, poll_id='34')

``poll_id='34'`` 这部分就是来自 ``(?P<poll_id>\d+)`` 匹配的结果。 使用括号包围一个
正则表达式所“捕获”的文本可作为一个参数传给视图函数；``?P<poll_id>`` 将会定义名称用于标识匹配的内容；
而 ``\d+`` 是一个用于匹配数字序列（即一个数字）的正则表达式。

因为 URL 模式是正则表达式，所以你可以毫无限制地使用它们。但是不要加上 URL 多余的部分如
``.html`` -- 除非你想，那你可以像下面这样：::

    (r'^polls/latest\.html$', 'polls.views.index'),

真的，不要这样做。这很傻。

在视图中添加些实际的功能
======================================

每个视图只负责以下两件事中的一件：返回一个
:class:`~django.http.HttpResponse` 对象，其中包含了所请求页面的内容，
或者抛出一个异常，例如 :exc:`~django.http.Http404` 。剩下的就由你来实现了。

你的视图可以读取数据库记录，或者不用。它可以使用一个模板系统，例如 Django 的 
-- 或者第三方的 Python 模板系统 -- 或不用。它可以生成一个 PDF 文件，输出 XML ，
即时创建 ZIP 文件， 你可以使用你想用的任何 Python 库来做你想做的任何事。

而 Django 只要求是一个 :class:`~django.http.HttpResponse` 或一个异常。

因为它很方便，那让我们来使用 Django 自己的数据库 API 吧，
在 :doc:`教程 第1部分 </intro/tutorial01>` 中提过。修改下 ``index()`` 视图，
让它显示系统中最新发布的 5 个调查问题，以逗号分割并按发布日期排序：::

    from django.http import HttpResponse

    from polls.models import Poll

    def index(request):
        latest_poll_list = Poll.objects.order_by('-pub_date')[:5]
        output = ', '.join([p.question for p in latest_poll_list])
        return HttpResponse(output)

在这就有了个问题，页面的设计是硬编码在视图中的。如果你想改变页面的外观，就必须修改这里的
Python 代码。因此，让我们使用 Django 的模板系统创建一个模板给视图用，就使设计和 Python 代码
分割开来了。

首先，在 ``polls`` 目录下创建一个 ``templates`` 目录。
Django 将会在那寻找模板。

Django's :setting:`TEMPLATE_LOADERS` setting contains a list of callables that
know how to import templates from various sources. One of the defaults is
:class:`django.template.loaders.app_directories.Loader` which looks for a
"templates" subdirectory in each of the :setting:`INSTALLED_APPS` - this is how
Django knows to find the polls templates even though we didn't modify
:setting:`TEMPLATE_DIRS`, as we did in :ref:`Tutorial 2
<ref-customizing-your-projects-templates>`.

.. admonition:: Organizing templates

    We *could* have all our templates together, in one big templates directory,
    and it would work perfectly well. However, this template belongs to the
    polls application, so unlike the admin template we created in the previous
    tutorial, we'll put this one in the application's template directory
    (``polls/templates``) rather than the project's (``templates``). We'll
    discuss in more detail in the :doc:`reusable apps tutorial
    </intro/reusable-apps>` *why* we do this.

Within the ``templates`` directory you have just created, create another
directory called ``polls``, and within that create a file called
``index.html``. In other words, your template should be at
``polls/templates/polls/index.html``. Because of how the ``app_directories``
template loader works as described above, you can refer to this template within
Django simply as ``polls/index.html``.

.. admonition:: Template namespacing

    Now we *might* be able to get away with putting our templates directly in
    ``polls/templates`` (rather than creating another ``polls`` subdirectory),
    but it would actually be a bad idea. Django will choose the first template
    it finds whose name matches, and if you had a template with the same name
    in a *different* application, Django would be unable to distinguish between
    them. We need to be able to point Django at the right one, and the easiest
    way to ensure this is by *namespacing* them. That is, by putting those
    templates inside *another* directory named for the application itself.

Put the following code in that template:

.. code-block:: html+django

    {% if latest_poll_list %}
        <ul>
        {% for poll in latest_poll_list %}
            <li><a href="/polls/{{ poll.id }}/">{{ poll.question }}</a></li>
        {% endfor %}
        </ul>
    {% else %}
        <p>No polls are available.</p>
    {% endif %}

Now let's use that html template in our index view::

    from django.http import HttpResponse
    from django.template import Context, loader

    from polls.models import Poll

    def index(request):
        latest_poll_list = Poll.objects.order_by('-pub_date')[:5]
        template = loader.get_template('polls/index.html')
        context = Context({
            'latest_poll_list': latest_poll_list,
        })
        return HttpResponse(template.render(context))

That code loads the template called  ``polls/index.html`` and passes it a
context. The context is a dictionary mapping template variable names to Python
objects.

Load the page by pointing your browser at "/polls/", and you should see a
bulleted-list containing the "What's up" poll from Tutorial 1. The link points
to the poll's detail page.

A shortcut: :func:`~django.shortcuts.render`
--------------------------------------------

It's a very common idiom to load a template, fill a context and return an
:class:`~django.http.HttpResponse` object with the result of the rendered
template. Django provides a shortcut. Here's the full ``index()`` view,
rewritten::

    from django.shortcuts import render

    from polls.models import Poll

    def index(request):
        latest_poll_list = Poll.objects.all().order_by('-pub_date')[:5]
        context = {'latest_poll_list': latest_poll_list}
        return render(request, 'polls/index.html', context)

Note that once we've done this in all these views, we no longer need to import
:mod:`~django.template.loader`, :class:`~django.template.Context` and
:class:`~django.http.HttpResponse` (you'll want to keep ``HttpResponse`` if you
still have the stub methods for ``detail``, ``results``, and ``vote``).

The :func:`~django.shortcuts.render` function takes the request object as its
first argument, a template name as its second argument and a dictionary as its
optional third argument. It returns an :class:`~django.http.HttpResponse`
object of the given template rendered with the given context.

Raising a 404 error
===================

Now, let's tackle the poll detail view -- the page that displays the question
for a given poll. Here's the view::

    from django.http import Http404
    # ...
    def detail(request, poll_id):
        try:
            poll = Poll.objects.get(pk=poll_id)
        except Poll.DoesNotExist:
            raise Http404
        return render(request, 'polls/detail.html', {'poll': poll})

The new concept here: The view raises the :exc:`~django.http.Http404` exception
if a poll with the requested ID doesn't exist.

We'll discuss what you could put in that ``polls/detail.html`` template a bit
later, but if you'd like to quickly get the above example working, a file
containing just::

    {{ poll }}

will get you started for now.

A shortcut: :func:`~django.shortcuts.get_object_or_404`
-------------------------------------------------------

It's a very common idiom to use :meth:`~django.db.models.query.QuerySet.get`
and raise :exc:`~django.http.Http404` if the object doesn't exist. Django
provides a shortcut. Here's the ``detail()`` view, rewritten::

    from django.shortcuts import render, get_object_or_404
    # ...
    def detail(request, poll_id):
        poll = get_object_or_404(Poll, pk=poll_id)
        return render(request, 'polls/detail.html', {'poll': poll})

The :func:`~django.shortcuts.get_object_or_404` function takes a Django model
as its first argument and an arbitrary number of keyword arguments, which it
passes to the :meth:`~django.db.models.query.QuerySet.get` function of the
model's manager. It raises :exc:`~django.http.Http404` if the object doesn't
exist.

.. admonition:: Philosophy

    Why do we use a helper function :func:`~django.shortcuts.get_object_or_404`
    instead of automatically catching the
    :exc:`~django.core.exceptions.ObjectDoesNotExist` exceptions at a higher
    level, or having the model API raise :exc:`~django.http.Http404` instead of
    :exc:`~django.core.exceptions.ObjectDoesNotExist`?

    Because that would couple the model layer to the view layer. One of the
    foremost design goals of Django is to maintain loose coupling. Some
    controlled coupling is introduced in the :mod:`django.shortcuts` module.

There's also a :func:`~django.shortcuts.get_list_or_404` function, which works
just as :func:`~django.shortcuts.get_object_or_404` -- except using
:meth:`~django.db.models.query.QuerySet.filter` instead of
:meth:`~django.db.models.query.QuerySet.get`. It raises
:exc:`~django.http.Http404` if the list is empty.

Write a 404 (page not found) view
=================================

When you raise :exc:`~django.http.Http404` from within a view, Django
will load a special view devoted to handling 404 errors. It finds it
by looking for the variable ``handler404`` in your root URLconf (and
only in your root URLconf; setting ``handler404`` anywhere else will
have no effect), which is a string in Python dotted syntax -- the same
format the normal URLconf callbacks use. A 404 view itself has nothing
special: It's just a normal view.

You normally won't have to bother with writing 404 views. If you don't set
``handler404``, the built-in view :func:`django.views.defaults.page_not_found`
is used by default. Optionally, you can create a ``404.html`` template
in the root of your template directory. The default 404 view will then use that
template for all 404 errors when :setting:`DEBUG` is set to ``False`` (in your
settings module). If you do create the template, add at least some dummy
content like "Page not found".

A couple more things to note about 404 views:

* If :setting:`DEBUG` is set to ``True`` (in your settings module) then your
  404 view will never be used (and thus the ``404.html`` template will never
  be rendered) because the traceback will be displayed instead.

* The 404 view is also called if Django doesn't find a match after checking
  every regular expression in the URLconf.

Write a 500 (server error) view
===============================

Similarly, your root URLconf may define a ``handler500``, which points
to a view to call in case of server errors. Server errors happen when
you have runtime errors in view code.

Likewise, you should create a ``500.html`` template at the root of your
template directory and add some content like "Something went wrong".

Use the template system
=======================

Back to the ``detail()`` view for our poll application. Given the context
variable ``poll``, here's what the ``polls/detail.html`` template might look
like:

.. code-block:: html+django

    <h1>{{ poll.question }}</h1>
    <ul>
    {% for choice in poll.choice_set.all %}
        <li>{{ choice.choice_text }}</li>
    {% endfor %}
    </ul>

The template system uses dot-lookup syntax to access variable attributes. In
the example of ``{{ poll.question }}``, first Django does a dictionary lookup
on the object ``poll``. Failing that, it tries an attribute lookup -- which
works, in this case. If attribute lookup had failed, it would've tried a
list-index lookup.

Method-calling happens in the :ttag:`{% for %}<for>` loop:
``poll.choice_set.all`` is interpreted as the Python code
``poll.choice_set.all()``, which returns an iterable of ``Choice`` objects and is
suitable for use in the :ttag:`{% for %}<for>` tag.

See the :doc:`template guide </topics/templates>` for more about templates.

Removing hardcoded URLs in templates
====================================

Remember, when we wrote the link to a poll in the ``polls/index.html``
template, the link was partially hardcoded like this:

.. code-block:: html+django

    <li><a href="/polls/{{ poll.id }}/">{{ poll.question }}</a></li>

The problem with this hardcoded, tightly-coupled approach is that it becomes
challenging to change URLs on projects with a lot of templates. However, since
you defined the name argument in the :func:`~django.conf.urls.url` functions in
the ``polls.urls`` module, you can remove a reliance on specific URL paths
defined in your url configurations by using the ``{% url %}`` template tag:

.. code-block:: html+django

    <li><a href="{% url 'detail' poll.id %}">{{ poll.question }}</a></li>

.. note::

    If ``{% url 'detail' poll.id %}`` (with quotes) doesn't work, but
    ``{% url detail poll.id %}`` (without quotes) does, that means you're
    using a version of Django < 1.5. In this case, add the following
    declaration at the top of your template:

    .. code-block:: html+django

        {% load url from future %}

The way this works is by looking up the URL definition as specified in the
``polls.urls`` module. You can see exactly where the URL name of 'detail' is
defined below::

    ...
    # the 'name' value as called by the {% url %} template tag
    url(r'^(?P<poll_id>\d+)/$', views.detail, name='detail'),
    ...

If you want to change the URL of the polls detail view to something else,
perhaps to something like ``polls/specifics/12/`` instead of doing it in the
template (or templates) you would change it in ``polls/urls.py``::

    ...
    # added the word 'specifics'
    url(r'^specifics/(?P<poll_id>\d+)/$', views.detail, name='detail'),
    ...

Namespacing URL names
======================

The tutorial project has just one app, ``polls``. In real Django projects,
there might be five, ten, twenty apps or more. How does Django differentiate
the URL names between them? For example, the ``polls`` app has a ``detail``
view, and so might an app on the same project that is for a blog. How does one
make it so that Django knows which app view to create for a url when using the
``{% url %}`` template tag?

The answer is to add namespaces to your root URLconf. In the ``mysite/urls.py``
file (the project's ``urls.py``, not the application's), go ahead and change
it to include namespacing::

    from django.conf.urls import patterns, include, url

    from django.contrib import admin
    admin.autodiscover()

    urlpatterns = patterns('',
        url(r'^polls/', include('polls.urls', namespace="polls")),
        url(r'^admin/', include(admin.site.urls)),
    )

Now change your ``polls/index.html`` template from:

.. code-block:: html+django

    <li><a href="{% url 'detail' poll.id %}">{{ poll.question }}</a></li>

to point at the namespaced detail view:

.. code-block:: html+django

    <li><a href="{% url 'polls:detail' poll.id %}">{{ poll.question }}</a></li>

When you're comfortable with writing views, read :doc:`part 4 of this tutorial
</intro/tutorial04>` to learn about simple form processing and generic views.
