=====================================
编写你的第一个 Django 程序 第3部分
=====================================

本教程上接 :doc:`教程 第2部分 </intro/tutorial02>` 。我们将继续
开发 Web-poll 应用并且专注在创建公共界面 --  "视图 （views ）"。

哲理
==========

在 Django 应用程序中，视图是一“类”具有特定功能和模板的网页。
例如，在一个博客应用程序中，你可能会有以下视图：

* 博客首页 -- 显示最新发表的博客。

* 博客详细页面 -- 一篇博客的独立页面。

* 基于年份的归档页 -- 显示给定年份中发表博客的所有月份。

* 基于月份的归档页 -- 显示给定月份中发表博客的所有日期。

* 基于日期的归档页 -- 显示给定日期中发表的所有的博客。

* 评论功能 -- 为一篇给定博客发表评论。

在我们的 poll 应用程序中，将有以下四个视图：

* Poll "index" 页 -- 显示最新发布的民意调查。

* Poll "detail" 页 -- 显示一项民意调查的具体问题，不显示该项的投票结果但可以进行投票的 form 。

* Poll "results" 页 -- 显示一项给定的民意调查的投票结果。

* 投票功能 -- 为一项给定的民意调查处理投票选项。

在 Django 中，网页及其他内容是由视图来展现的。而每个视图就是一个简单的 Python 函数（或方法，
对于基于类的视图情况下）。Django 会通过检查所请求的 URL （确切地说是域名之后的那部分 URL）来匹配一个视图。

平时你上网的时候可能会遇到像
"ME2/Sites/dirmod.asp?sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B" 这种如此美丽的 URL。
但是你会很高兴知道 Django 允许我们使用比那优雅的 *URL 模式* 来展现 URL。

URL 模式就是一个简单的一般形式的 URL - 比如:
``/newsarchive/<year>/<month>/``.

Django 是通过 'URLconfs' 从 URL 获取到视图的。而
URLconf 是将 URL 模式 ( 由正则表达式来描述的 ) 映射到视图的一种配置。

本教程中介绍了使用 URLconfs 的基本指令，你可以查阅
:mod:`django.core.urlresolvers` 来获取更多信息。

编写你的第一个视图
=====================

让我们编写第一个视图。打开文件 ``polls/views.py``
并在其中输入以下 Python 代码 ::

    from django.http import HttpResponse

    def index(request):
        return HttpResponse("Hello, world. You're at the poll index.")

在 Django 中这可能是最简单的视图了。为了调用这个视图，我们需要将它映射到一个 URL
-- 为此我们需要配置一个URLconf 。

在 polls 目录下创建一个名为 ``urls.py`` 的 URLconf 文档。
你的应用目录现在看起来像这样 ::

    polls/
        __init__.py
        admin.py
        models.py
        tests.py
        urls.py
        views.py

在 ``polls/urls.py`` 文件中输入以下代码： ::

    from django.conf.urls import patterns, url

    from polls import views

    urlpatterns = patterns('',
        url(r'^$', views.index, name='index')
    )

下一步是将 ``polls.urls`` 模块指向 root URLconf 。在
``mysite/urls.py`` 中插入一个 :func:`~django.conf.urls.include` 方法，最后的样子如下所示 ::

    from django.conf.urls import patterns, include, url

    from django.contrib import admin
    admin.autodiscover()

    urlpatterns = patterns('',
        url(r'^polls/', include('polls.urls')),
        url(r'^admin/', include(admin.site.urls)),
    )

现在你在 URLconf 中配置了 `index` 视图。通过浏览器访问
http://localhost:8000/polls/ ，如同你在 ``index`` 视图中定义的一样，你将看到
"*Hello, world. You're at the poll index.*" 文字。

:func:`~django.conf.urls.url` 函数有四个参数，两个必须的： ``regex`` 和 ``view``， 两个可选的： ``kwargs``， 以及 ``name``。
接下来，来探讨下这些参数的意义。

:func:`~django.conf.urls.url` 参数: regex
---------------------------------------------

`regex` 是 `regular expression` 的简写，这是字符串中的模式匹配的一种语法，
在 Django 中就是是 url 匹配模式。
Django 将请求的 URL 从上至下依次匹配列表中的正则表达式，直到匹配到一个为止。

需要注意的是，这些正则表达式不会匹配 GET 和 POST 参数，以及域名。
例如：针对 ``http://www.example.com/myapp/`` 这一请求，URLconf 将只查找 ``myapp/``。而在
``http://www.example.com/myapp/?page=3`` 中 URLconf 也仅查找 ``myapp/`` 。

如果你需要正则表达式方面的帮助，请参阅 `Wikipedia's entry`_ 和本文档中的 :mod:`re` 模块。
此外，O'Reilly 出版的由 Jeffrey Friedl 著的 "Mastering Regular Expressions" 也是不错的。
但是，实际上，你并不需要成为一个正则表达式的专家，仅仅需要知道如何捕获简单的模式。
事实上，复杂的正则表达式会降低查找性能，因此你不能完全依赖正则表达式的功能。

最后有个性能上的提示：这些正则表达式在 URLconf 模块第一次加载时会被编译。
因此它们速度超快 ( 像上面提到的那样只要查找的不是太复杂 )。

.. _Wikipedia's entry: http://en.wikipedia.org/wiki/Regular_expression

:func:`~django.conf.urls.url` 参数： view
--------------------------------------------

当 Django 匹配了一个正则表达式就会调用指定的视图功能，包含一个
:class:`~django.http.HttpRequest` 实例作为第一个参数和正则表达式
“捕获” 的一些值的作为其他参数。
如果使用简单的正则捕获，将按顺序位置传参数；如果按命名的正则捕获，将按关键字传参数值。
有关这一点我们会给出一个例子。

:func:`~django.conf.urls.url` 参数： kwargs
----------------------------------------------

任意关键字参数可传一个字典至目标视图。在本教程中，我们并不打算使用 Django 这一特性。

:func:`~django.conf.urls.url` 参数： name
---------------------------------------------

命名你的 URL ，让你在 Django 的其他地方明确地引用它，特别是在模板中。
这一强大的功能可允许你通过一个文件就可全局修改项目中的 URL 模式。

编写更多视图
==================

现在让我们添加一些视图到 ``polls/views.py`` 中去。这些视图与之前的略有不同，因为
它们有一个参数：::

    def detail(request, poll_id):
        return HttpResponse("You're looking at poll %s." % poll_id)

    def results(request, poll_id):
        return HttpResponse("You're looking at the results of poll %s." % poll_id)

    def vote(request, poll_id):
        return HttpResponse("You're voting on poll %s." % poll_id)

将新视图按如下所示的 :func:`~django.conf.urls.url` 方法添加到
``polls.urls`` 模块中去：::

    from django.conf.urls import patterns, url

    from polls import views

    urlpatterns = patterns('',
        # ex: /polls/
        url(r'^$', views.index, name='index'),
        # ex: /polls/5/
        url(r'^(?P<poll_id>\d+)/$', views.detail, name='detail'),
        # ex: /polls/5/results/
        url(r'^(?P<poll_id>\d+)/results/$', views.results, name='results'),
        # ex: /polls/5/vote/
        url(r'^(?P<poll_id>\d+)/vote/$', views.vote, name='vote'),
    )

在你的浏览器中访问 http://localhost:8000/polls/34/ 。将运行 ``detail()``
方法并且显示你在 URL 中提供的任意 ID 。试着访问 http://localhost:8000/polls/34/results/ 
和 http://localhost:8000/polls/34/vote/ -- 将会显示对应的结果页及投票页。

当有人访问你的网站页面如 “ /polls/34/ ” 时，Django 会加载 ``mysite.urls`` 模块，这是因为
:setting:`ROOT_URLCONF` 设置指向它。接着在该模块中寻找名为``urlpatterns`` 的变量并依次匹配其中的正则表达式。
:func:`~django.conf.urls.include` 可让我们便利地引用其他 URLconfs 。请注意
:func:`~django.conf.urls.include` 中的正则表达式没有 ``$`` (字符串结尾的匹配符
match character) 而尾部是一个反斜杠。当 Django 解析
:func:`~django.conf.urls.include` 时，它截取匹配的 URL 那部分而把剩余的字符串交由
加载进来的 URLconf 作进一步处理。


:func:`~django.conf.urls.include` 背后隐藏的想法是使 URLs 即插即用。
由于 polls 在自己的 URLconf(``polls/urls.py``) 中，因此它们可以被放置在 "/polls/" 路径下，或
"/fun_polls/" 路径下，或 "/content/polls/" 路径下，或者其他根路径，而应用仍可以运行。

以下是当用户访问 "/polls/34/" 路径时系统中将发生的事：

* Django 将寻找 ``'^polls/'`` 的匹配

* 接着，Django 截取匹配文本 (``"polls/"``) 后剩余的文本
  -- ``"34/"`` -- 传递到 'polls.urls' URLconf 中作进一步处理，
  再将匹配 ``r'^(?P<poll_id>\d+)/$'`` 的结果作为参数传给 ``detail()`` 视图 ::

    detail(request=<HttpRequest object>, poll_id='34')

``poll_id='34'`` 这部分就是来自 ``(?P<poll_id>\d+)`` 匹配的结果。 使用括号包围一个
正则表达式所“捕获”的文本可作为一个参数传给视图函数；``?P<poll_id>`` 将会定义名称用于标识匹配的内容；
而 ``\d+`` 是一个用于匹配数字序列（即一个数字）的正则表达式。

因为 URL 模式是正则表达式，所以你可以毫无限制地使用它们。但是不要加上 URL 多余的部分如
``.html`` -- 除非你想，那你可以像下面这样：::

    (r'^polls/latest\.html$', 'polls.views.index'),

真的，不要这样做。这很傻。

在视图中添加些实际的功能
======================================

每个视图只负责以下两件事中的一件：返回一个
:class:`~django.http.HttpResponse` 对象，其中包含了所请求页面的内容，
或者抛出一个异常，例如 :exc:`~django.http.Http404` 。剩下的就由你来实现了。

你的视图可以读取数据库记录，或者不用。它可以使用一个模板系统，例如 Django 的 
-- 或者第三方的 Python 模板系统 -- 或不用。它可以生成一个 PDF 文件，输出 XML ，
即时创建 ZIP 文件， 你可以使用你想用的任何 Python 库来做你想做的任何事。

而 Django 只要求是一个 :class:`~django.http.HttpResponse` 或一个异常。

因为它很方便，那让我们来使用 Django 自己的数据库 API 吧，
在 :doc:`教程 第1部分 </intro/tutorial01>` 中提过。修改下 ``index()`` 视图，
让它显示系统中最新发布的 5 个调查问题，以逗号分割并按发布日期排序：::

    from django.http import HttpResponse

    from polls.models import Poll

    def index(request):
        latest_poll_list = Poll.objects.order_by('-pub_date')[:5]
        output = ', '.join([p.question for p in latest_poll_list])
        return HttpResponse(output)

在这就有了个问题，页面的设计是硬编码在视图中的。如果你想改变页面的外观，就必须修改这里的
Python 代码。因此，让我们使用 Django 的模板系统创建一个模板给视图用，就使页面设计从 Python 代码中
分离出来了。

首先，在 ``polls`` 目录下创建一个 ``templates`` 目录。
Django 将会在那寻找模板。

Django 的 :setting:`TEMPLATE_LOADERS` 配置中包含一个知道如何从各种来源导入模板的可调用的方法列表。
其中有一个默认值是 :class:`django.template.loaders.app_directories.Loader` ，Django 就会在每个 :setting:`INSTALLED_APPS` 
的 "templates" 子目录下查找模板 - 这就是 Django 知道怎么找到 polls 模板的原因，即使我们
没有修改 :setting:`TEMPLATE_DIRS`, 还是如同在 :ref:`教程 第2部分
<ref-customizing-your-projects-templates>` 那样。

.. admonition:: 组织模板

    我们 *能够* 在一个大的模板目录下一起共用我们所有的模板，而且它们会运行得很好。
    但是，此模板属于 polls 应用，因此与我们在上一个教程中创建的管理模板不同，
    我们要把这个模板放在应用的模板目录 (``polls/templates``) 下而不是项目的模板目录 (``templates``) 。
    我们将在 :doc:`可重用的应用教程 
    </intro/reusable-apps>` 中详细讨论我们 *为什么* 要这样做。

在你刚才创建的``templates`` 目录下，另外创建个名为 
``polls`` 的目录，并在其中创建一个 
``index.html`` 文件。换句话说，你的模板应该是
``polls/templates/polls/index.html`` 。由于知道如上所述的 ``app_directories`` 模板加载器是
如何运行的，你可以参考 Django 内的模板简单的作为 ``polls/index.html`` 模板。

.. admonition:: 模板命名空间

    现在我们 *也许* 能够直接把我们的模板放在
    ``polls/templates`` 目录下 ( 而不是另外创建 ``polls`` 子目录 ) ，
    但它实际上是一个坏注意。 Django 将会选择第一个找到的按名称匹配的模板，
    如果你在 *不同* 应用中有相同的名称的模板，Django 将无法区分它们。
    我们想要让 Django 指向正确的模板，最简单的方法是通过 *命名空间* 来确保是
    他们的模板。也就是说，将模板放在 *另一个* 目录下并命名为应用本身的名称。

将以下代码添加到该模板中:

.. code-block:: html+django

    {% if latest_poll_list %}
        <ul>
        {% for poll in latest_poll_list %}
            <li><a href="/polls/{{ poll.id }}/">{{ poll.question }}</a></li>
        {% endfor %}
        </ul>
    {% else %}
        <p>No polls are available.</p>
    {% endif %}

现在让我们在 index 视图中使用这个模板：  ::

    from django.http import HttpResponse
    from django.template import Context, loader

    from polls.models import Poll

    def index(request):
        latest_poll_list = Poll.objects.order_by('-pub_date')[:5]
        template = loader.get_template('polls/index.html')
        context = Context({
            'latest_poll_list': latest_poll_list,
        })
        return HttpResponse(template.render(context))

代码将加载 ``polls/index.html`` 模板并传递一个 context 变量。 The context is a dictionary mapping template variable names to Python
该 context 变量是一个映射了 Python 对象到模板变量的字典。

在你的浏览器中加载 "/polls/" 页，你应该看到一个列表，包含了在教程 第1部分 中创建的
"What's up" 调查。而链接指向 poll 的详细页面。

快捷方式: :func:`~django.shortcuts.render`
--------------------------------------------

这是一个非常常见的习惯用语，用于加载模板，填充上下文并返回一个含有模板渲染结果的
:class:`~django.http.HttpResponse` 对象。
Django 提供了一种快捷方式。这里重写完整的 ``index()`` 视图 ::

    from django.shortcuts import render

    from polls.models import Poll

    def index(request):
        latest_poll_list = Poll.objects.all().order_by('-pub_date')[:5]
        context = {'latest_poll_list': latest_poll_list}
        return render(request, 'polls/index.html', context)

请注意，一旦我们在所有视图中都这样做了，我们就不再需要导入
:mod:`~django.template.loader` ， :class:`~django.template.Context` 和
:class:`~django.http.HttpResponse` ( 如果你仍然保留了 ``detail``,``resutls``, 和``vote`` 方法，你还是需要保留 ``HttpResponse`` 
) 。

:func:`~django.shortcuts.render` 函数中第一个参数是 request 对象，第二个参数是一个模板名称，第三个是一个字典类型的可选参数。
它将返回一个包含有给定模板根据给定的上下文渲染结果的 :class:`~django.http.HttpResponse` 对象。

抛出 404 异常
===================

现在让我们解决 poll 的详细视图 -- 该页显示一个给定 poll 的详细问题。
视图代码如下所示：::

    from django.http import Http404
    # ...
    def detail(request, poll_id):
        try:
            poll = Poll.objects.get(pk=poll_id)
        except Poll.DoesNotExist:
            raise Http404
        return render(request, 'polls/detail.html', {'poll': poll})

在这有个新概念：如果请求的 poll 的 ID 不存在，该视图将抛出 :exc:`~django.http.Http404` 异常。

我们稍后讨论如何设置 ``polls/detail.html`` 模板，若是你想快速运行上面的例子，
在模板文件中添加如下代码： ::

    {{ poll }}

现在你可以运行了。

快捷方式: :func:`~django.shortcuts.get_object_or_404`
-------------------------------------------------------

It's a very common idiom to use :meth:`~django.db.models.query.QuerySet.get`
and raise :exc:`~django.http.Http404` if the object doesn't exist. Django
provides a shortcut. Here's the ``detail()`` view, rewritten::

    from django.shortcuts import render, get_object_or_404
    # ...
    def detail(request, poll_id):
        poll = get_object_or_404(Poll, pk=poll_id)
        return render(request, 'polls/detail.html', {'poll': poll})

The :func:`~django.shortcuts.get_object_or_404` function takes a Django model
as its first argument and an arbitrary number of keyword arguments, which it
passes to the :meth:`~django.db.models.query.QuerySet.get` function of the
model's manager. It raises :exc:`~django.http.Http404` if the object doesn't
exist.

.. admonition:: Philosophy

    Why do we use a helper function :func:`~django.shortcuts.get_object_or_404`
    instead of automatically catching the
    :exc:`~django.core.exceptions.ObjectDoesNotExist` exceptions at a higher
    level, or having the model API raise :exc:`~django.http.Http404` instead of
    :exc:`~django.core.exceptions.ObjectDoesNotExist`?

    Because that would couple the model layer to the view layer. One of the
    foremost design goals of Django is to maintain loose coupling. Some
    controlled coupling is introduced in the :mod:`django.shortcuts` module.

There's also a :func:`~django.shortcuts.get_list_or_404` function, which works
just as :func:`~django.shortcuts.get_object_or_404` -- except using
:meth:`~django.db.models.query.QuerySet.filter` instead of
:meth:`~django.db.models.query.QuerySet.get`. It raises
:exc:`~django.http.Http404` if the list is empty.

Write a 404 (page not found) view
=================================

When you raise :exc:`~django.http.Http404` from within a view, Django
will load a special view devoted to handling 404 errors. It finds it
by looking for the variable ``handler404`` in your root URLconf (and
only in your root URLconf; setting ``handler404`` anywhere else will
have no effect), which is a string in Python dotted syntax -- the same
format the normal URLconf callbacks use. A 404 view itself has nothing
special: It's just a normal view.

You normally won't have to bother with writing 404 views. If you don't set
``handler404``, the built-in view :func:`django.views.defaults.page_not_found`
is used by default. Optionally, you can create a ``404.html`` template
in the root of your template directory. The default 404 view will then use that
template for all 404 errors when :setting:`DEBUG` is set to ``False`` (in your
settings module). If you do create the template, add at least some dummy
content like "Page not found".

A couple more things to note about 404 views:

* If :setting:`DEBUG` is set to ``True`` (in your settings module) then your
  404 view will never be used (and thus the ``404.html`` template will never
  be rendered) because the traceback will be displayed instead.

* The 404 view is also called if Django doesn't find a match after checking
  every regular expression in the URLconf.

Write a 500 (server error) view
===============================

Similarly, your root URLconf may define a ``handler500``, which points
to a view to call in case of server errors. Server errors happen when
you have runtime errors in view code.

Likewise, you should create a ``500.html`` template at the root of your
template directory and add some content like "Something went wrong".

Use the template system
=======================

Back to the ``detail()`` view for our poll application. Given the context
variable ``poll``, here's what the ``polls/detail.html`` template might look
like:

.. code-block:: html+django

    <h1>{{ poll.question }}</h1>
    <ul>
    {% for choice in poll.choice_set.all %}
        <li>{{ choice.choice_text }}</li>
    {% endfor %}
    </ul>

The template system uses dot-lookup syntax to access variable attributes. In
the example of ``{{ poll.question }}``, first Django does a dictionary lookup
on the object ``poll``. Failing that, it tries an attribute lookup -- which
works, in this case. If attribute lookup had failed, it would've tried a
list-index lookup.

Method-calling happens in the :ttag:`{% for %}<for>` loop:
``poll.choice_set.all`` is interpreted as the Python code
``poll.choice_set.all()``, which returns an iterable of ``Choice`` objects and is
suitable for use in the :ttag:`{% for %}<for>` tag.

See the :doc:`template guide </topics/templates>` for more about templates.

Removing hardcoded URLs in templates
====================================

Remember, when we wrote the link to a poll in the ``polls/index.html``
template, the link was partially hardcoded like this:

.. code-block:: html+django

    <li><a href="/polls/{{ poll.id }}/">{{ poll.question }}</a></li>

The problem with this hardcoded, tightly-coupled approach is that it becomes
challenging to change URLs on projects with a lot of templates. However, since
you defined the name argument in the :func:`~django.conf.urls.url` functions in
the ``polls.urls`` module, you can remove a reliance on specific URL paths
defined in your url configurations by using the ``{% url %}`` template tag:

.. code-block:: html+django

    <li><a href="{% url 'detail' poll.id %}">{{ poll.question }}</a></li>

.. note::

    If ``{% url 'detail' poll.id %}`` (with quotes) doesn't work, but
    ``{% url detail poll.id %}`` (without quotes) does, that means you're
    using a version of Django < 1.5. In this case, add the following
    declaration at the top of your template:

    .. code-block:: html+django

        {% load url from future %}

The way this works is by looking up the URL definition as specified in the
``polls.urls`` module. You can see exactly where the URL name of 'detail' is
defined below::

    ...
    # the 'name' value as called by the {% url %} template tag
    url(r'^(?P<poll_id>\d+)/$', views.detail, name='detail'),
    ...

If you want to change the URL of the polls detail view to something else,
perhaps to something like ``polls/specifics/12/`` instead of doing it in the
template (or templates) you would change it in ``polls/urls.py``::

    ...
    # added the word 'specifics'
    url(r'^specifics/(?P<poll_id>\d+)/$', views.detail, name='detail'),
    ...

Namespacing URL names
======================

The tutorial project has just one app, ``polls``. In real Django projects,
there might be five, ten, twenty apps or more. How does Django differentiate
the URL names between them? For example, the ``polls`` app has a ``detail``
view, and so might an app on the same project that is for a blog. How does one
make it so that Django knows which app view to create for a url when using the
``{% url %}`` template tag?

The answer is to add namespaces to your root URLconf. In the ``mysite/urls.py``
file (the project's ``urls.py``, not the application's), go ahead and change
it to include namespacing::

    from django.conf.urls import patterns, include, url

    from django.contrib import admin
    admin.autodiscover()

    urlpatterns = patterns('',
        url(r'^polls/', include('polls.urls', namespace="polls")),
        url(r'^admin/', include(admin.site.urls)),
    )

Now change your ``polls/index.html`` template from:

.. code-block:: html+django

    <li><a href="{% url 'detail' poll.id %}">{{ poll.question }}</a></li>

to point at the namespaced detail view:

.. code-block:: html+django

    <li><a href="{% url 'polls:detail' poll.id %}">{{ poll.question }}</a></li>

When you're comfortable with writing views, read :doc:`part 4 of this tutorial
</intro/tutorial04>` to learn about simple form processing and generic views.
